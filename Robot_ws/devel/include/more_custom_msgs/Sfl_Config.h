// Generated by gencpp from file more_custom_msgs/Sfl_Config.msg
// DO NOT EDIT!


#ifndef MORE_CUSTOM_MSGS_MESSAGE_SFL_CONFIG_H
#define MORE_CUSTOM_MSGS_MESSAGE_SFL_CONFIG_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace more_custom_msgs
{
template <class ContainerAllocator>
struct Sfl_Config_
{
  typedef Sfl_Config_<ContainerAllocator> Type;

  Sfl_Config_()
    : header()
    , serialnumber(0)
    , defaultHue(0)
    , defaultSaturation(0)
    , defaultValue(0)
    , fadetime(0)
    , lightPowerOnStart(0)
    , lightStartUpMode(0)
    , declination(0.0)
    , topPirMask(0)
    , bottomPirMask(0)
    , rfChannel(0)
    , rfSSID(0)
    , rfPower(0)
    , rfNumHoppingChannels(0)
    , rfSelfSynced(0)
    , rfEncryption(0)  {
    }
  Sfl_Config_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , serialnumber(0)
    , defaultHue(0)
    , defaultSaturation(0)
    , defaultValue(0)
    , fadetime(0)
    , lightPowerOnStart(0)
    , lightStartUpMode(0)
    , declination(0.0)
    , topPirMask(0)
    , bottomPirMask(0)
    , rfChannel(0)
    , rfSSID(0)
    , rfPower(0)
    , rfNumHoppingChannels(0)
    , rfSelfSynced(0)
    , rfEncryption(0)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef uint32_t _serialnumber_type;
  _serialnumber_type serialnumber;

   typedef uint16_t _defaultHue_type;
  _defaultHue_type defaultHue;

   typedef uint8_t _defaultSaturation_type;
  _defaultSaturation_type defaultSaturation;

   typedef uint8_t _defaultValue_type;
  _defaultValue_type defaultValue;

   typedef uint16_t _fadetime_type;
  _fadetime_type fadetime;

   typedef uint8_t _lightPowerOnStart_type;
  _lightPowerOnStart_type lightPowerOnStart;

   typedef uint8_t _lightStartUpMode_type;
  _lightStartUpMode_type lightStartUpMode;

   typedef float _declination_type;
  _declination_type declination;

   typedef uint16_t _topPirMask_type;
  _topPirMask_type topPirMask;

   typedef uint16_t _bottomPirMask_type;
  _bottomPirMask_type bottomPirMask;

   typedef uint8_t _rfChannel_type;
  _rfChannel_type rfChannel;

   typedef uint8_t _rfSSID_type;
  _rfSSID_type rfSSID;

   typedef uint8_t _rfPower_type;
  _rfPower_type rfPower;

   typedef uint8_t _rfNumHoppingChannels_type;
  _rfNumHoppingChannels_type rfNumHoppingChannels;

   typedef uint8_t _rfSelfSynced_type;
  _rfSelfSynced_type rfSelfSynced;

   typedef uint8_t _rfEncryption_type;
  _rfEncryption_type rfEncryption;





  typedef boost::shared_ptr< ::more_custom_msgs::Sfl_Config_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::more_custom_msgs::Sfl_Config_<ContainerAllocator> const> ConstPtr;

}; // struct Sfl_Config_

typedef ::more_custom_msgs::Sfl_Config_<std::allocator<void> > Sfl_Config;

typedef boost::shared_ptr< ::more_custom_msgs::Sfl_Config > Sfl_ConfigPtr;
typedef boost::shared_ptr< ::more_custom_msgs::Sfl_Config const> Sfl_ConfigConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::more_custom_msgs::Sfl_Config_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::more_custom_msgs::Sfl_Config_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace more_custom_msgs

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': False, 'IsMessage': True, 'HasHeader': True}
// {'std_msgs': ['/opt/ros/kinetic/share/std_msgs/cmake/../msg'], 'geometry_msgs': ['/opt/ros/kinetic/share/geometry_msgs/cmake/../msg'], 'more_custom_msgs': ['/home/thilina/development/robot_ws/Robot_ws/src/more_custom_msgs/msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::more_custom_msgs::Sfl_Config_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::more_custom_msgs::Sfl_Config_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::more_custom_msgs::Sfl_Config_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::more_custom_msgs::Sfl_Config_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::more_custom_msgs::Sfl_Config_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::more_custom_msgs::Sfl_Config_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::more_custom_msgs::Sfl_Config_<ContainerAllocator> >
{
  static const char* value()
  {
    return "97a7cf28254b4ab1c008a870ba7f96e0";
  }

  static const char* value(const ::more_custom_msgs::Sfl_Config_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x97a7cf28254b4ab1ULL;
  static const uint64_t static_value2 = 0xc008a870ba7f96e0ULL;
};

template<class ContainerAllocator>
struct DataType< ::more_custom_msgs::Sfl_Config_<ContainerAllocator> >
{
  static const char* value()
  {
    return "more_custom_msgs/Sfl_Config";
  }

  static const char* value(const ::more_custom_msgs::Sfl_Config_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::more_custom_msgs::Sfl_Config_<ContainerAllocator> >
{
  static const char* value()
  {
    return "std_msgs/Header header\n\
uint32         serialnumber\n\
uint16         defaultHue\n\
uint8          defaultSaturation\n\
uint8          defaultValue\n\
uint16         fadetime\n\
uint8          lightPowerOnStart\n\
uint8          lightStartUpMode\n\
float32        declination\n\
uint16         topPirMask\n\
uint16         bottomPirMask\n\
uint8          rfChannel\n\
uint8          rfSSID\n\
uint8          rfPower\n\
uint8          rfNumHoppingChannels\n\
uint8          rfSelfSynced\n\
uint8          rfEncryption\n\
\n\
================================================================================\n\
MSG: std_msgs/Header\n\
# Standard metadata for higher-level stamped data types.\n\
# This is generally used to communicate timestamped data \n\
# in a particular coordinate frame.\n\
# \n\
# sequence ID: consecutively increasing ID \n\
uint32 seq\n\
#Two-integer timestamp that is expressed as:\n\
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n\
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n\
# time-handling sugar is provided by the client library\n\
time stamp\n\
#Frame this data is associated with\n\
# 0: no frame\n\
# 1: global frame\n\
string frame_id\n\
";
  }

  static const char* value(const ::more_custom_msgs::Sfl_Config_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::more_custom_msgs::Sfl_Config_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.serialnumber);
      stream.next(m.defaultHue);
      stream.next(m.defaultSaturation);
      stream.next(m.defaultValue);
      stream.next(m.fadetime);
      stream.next(m.lightPowerOnStart);
      stream.next(m.lightStartUpMode);
      stream.next(m.declination);
      stream.next(m.topPirMask);
      stream.next(m.bottomPirMask);
      stream.next(m.rfChannel);
      stream.next(m.rfSSID);
      stream.next(m.rfPower);
      stream.next(m.rfNumHoppingChannels);
      stream.next(m.rfSelfSynced);
      stream.next(m.rfEncryption);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct Sfl_Config_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::more_custom_msgs::Sfl_Config_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::more_custom_msgs::Sfl_Config_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "serialnumber: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.serialnumber);
    s << indent << "defaultHue: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.defaultHue);
    s << indent << "defaultSaturation: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.defaultSaturation);
    s << indent << "defaultValue: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.defaultValue);
    s << indent << "fadetime: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.fadetime);
    s << indent << "lightPowerOnStart: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.lightPowerOnStart);
    s << indent << "lightStartUpMode: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.lightStartUpMode);
    s << indent << "declination: ";
    Printer<float>::stream(s, indent + "  ", v.declination);
    s << indent << "topPirMask: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.topPirMask);
    s << indent << "bottomPirMask: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.bottomPirMask);
    s << indent << "rfChannel: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.rfChannel);
    s << indent << "rfSSID: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.rfSSID);
    s << indent << "rfPower: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.rfPower);
    s << indent << "rfNumHoppingChannels: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.rfNumHoppingChannels);
    s << indent << "rfSelfSynced: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.rfSelfSynced);
    s << indent << "rfEncryption: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.rfEncryption);
  }
};

} // namespace message_operations
} // namespace ros

#endif // MORE_CUSTOM_MSGS_MESSAGE_SFL_CONFIG_H
